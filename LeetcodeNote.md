# Leetcode 题解思路总结



### Lc04 寻找两个正序数组的中位数

给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。
中位数问题可以转化成找第k大的数。

因为中位数的位置是固定的，等于m+n+1>>1；这里加1是因为当m+n是奇数时，中位数会比二分位多一位，比如5的中位数是3而不是2，加1对偶数不会有影响。

由于在合并后的数组中位置固定，可以预料的是，合并后中位数左边的数有k个并且都有序。即找到合并后数组的第k个数字。但是先合并后找复杂度过高，需要直接在原数组上找出第k个数据。

由于两个数组有序，我们可以在两个数组上分别化一道边界，使得边界左边的数都是合并后数组的前k个数字里的值。如图，合并后数组的AB段别来自与原数组的前半段。

找到这两个边界的条件是，边界左边的数据个数等于k且左边任一数据都比右边小。转换成条件，我们可以先固定元素个数k，将两个指针离0位置的长度和固定为k就可以；然后要保证左边的数据比右边小，即不能存在右边的数据比边界元素还小的情况，如果存在就需要移动边界。

为了让边界一直左右反复调整，我们可以让长数组上的边界最大，比如k个元素都放在长数组上，然后逐渐缩短长数组的边界，增加短数组的边界，这样调整的顺序是固定的。



![](img\leetcode\04\合并.png)



### Lc11 盛最多水的容器

![盛水最多的容器](https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg)

典型的双指针法题目。

盛水的多少取决于两块板的高度和中间的距离，这种取决于多个因素取最值的问题，可以采用先固定一个因素，逐步缩减其他因素的思想。

如此题中先确定两块板的距离，首先采用最远距离的两块板，计算出盛水容量，然后变动某一块板的高度观察是否能取得更多的盛水量。高度取决于短的一块板，所以移动短的一块板。如果移动一步并没有使容量增大，则继续移动短的一块。直到找到更大的。

在此步骤中，由于要移动左右两块板，双指针法显然是最合适的。



### Lc15 三数之和

判断是否有三个数和等于目标数。



与Lc11的思路一样，三个加数相当于三个变量，我们需要固定其中一个，变动剩余两个来寻找最合适的结果。这种剩余两个变量的情况一般都采用双指针。在指针移动时必须能够确定移动后的结果比当前结果更靠近目标还是更远离目标，在这里乱序的数组并不能保证，所以需要先排序。



具体的实现思路是：排序后，先固定一个数A，在后续的数据中用双指针法寻找两个数，使得两数相加等于target-A；

由于原始数据是可能有重复值的，又不允许重复三元组，所以去重是关键点。

去重一般会想到HashMap，但最好是能在逻辑中去除相同的结果，这样会省去很多查询结束后的处理过程。

在本题的查询过程中，重复结果都是由重复数据引起的，所以在双指针遍历过程中，左右指针都不访问相同的元素就可以做到去重。因为先进行了排序，重复的数据都排在一起，所以实现还是比较方便的。



### Lc16 最接近的三数之和

找出与目标值最接近的三个数之和

跟Lc15的题目很像，思路也是类似，仍然是固定一个数，双指针查找另外两个数，这里是找最接近的和，所以要在遍历过程中加入查找max的逻辑。因为只要返回和，就不需要去重操作了。



### Lc19 删除链表的倒数第 N 个结点

快慢指针法。让一个指针先走N步，当快指针到达末尾时，慢指针正好指向倒数第n+1个节点，即可删除。

注意特殊情况，如只有一个节点、删除头节点等



### Lc22 括号生成

生成n对括号，输出所有可能的组合。

这种全排列问题通过回溯剪枝法都可以解决。

回溯法最好是用递归去写，简洁方便，迭代比较复杂。

剪枝的条件比较明显，当结果中右括号的数量比左括号还多时，说明当前的结果中出现了没有对应左括号的右括号，就可以不用往下找了。

递归的终止条件是左右括号数量都用完了。



### Lc22 两两交换链表中的节点

观察交换两个节点的过程会发现，交换过程中会影响三个节点，这两个节点和前一个节点，而链表的第一个节点没有前节点，可以加入一个pre节点指向head。

这样在交换过程中形式统一。

可以采用迭代或者递归的形式，每次交换完成后，pre指针向后移动两次，正好指向后面要交换的两个节点的前一节点。



### Lc29 两数相除

模拟整数除法，数据范围[-2^31,2^31-1]，如果结果溢出返回2^31-1。不能使用乘法。

因为无法使用乘法，想快速累积被除数的倍数只能通过左移<<，相当于乘以2^n。

举例：

25除以4:

25=16+8+1=4\*4+4\*2+1=4<<2 + 4<<1 + 1

即25/4的结果等于2^2+2^1=4+2=6



在实现的过程中，该流程表现为25-4<<i++; 其中i从0开始不断增加，

关于溢出的处理：

+ 在计算之前要对-1，1，0等做特殊处理
+ 由于负数的范围是[-2^31,0]比正数要大，所以可以全部转换成负数来算，等计算出结果再计算正负。
+ 在计算过程中，由于存在对除数的左移，是有可能存在溢出情况的，需要判断左移是否会溢出。判断的方法是，把Integer.MIN_VALUE>>i右移相同位数，看看当前值是不是比这个值还小，如果更小再左移就会溢出了。
+ 当左移后的数据比当前结果还要大时（全换成负数时是更小），说明已经除完了。此时如果左移的结果溢出，应该用Integer.MIN_VAULE来替换。



### Lc33 搜索旋转排序数组

旋转数组是把有序数组的头部一段数组移动拼接到尾部。要求O(logn)

从时间复杂度看很明显要用二分。

有序并不是二分的必要条件，二分的本质是找到目标的确切范围，如果能够确定在某种情况下目标一定在某一个范围内，且不在这种情况下目标一定不在该范围内，就可以用这个逻辑作为二分的条件。二分的关键就是找到这种条件。

比如在此题中，可以通过mid与数组首个数字的对比判断mid落在前半部分还是后半部分。缩小一次范围的情况下，如果mid落在前半部分，如果x也落在前半部分而且比mid要小，说明x一定在start和mid中间，这样就形成了一个二分条件。同理如果mid落在后半部分，x也落在后半部分且比mid要大，x一定在mid和end中间，也形成了一个二分条件。



关于模板：

```
// 模板1
int mid = l+r>>1;
if(check()){
	l=mid+1;
}else r=mid;

// 模板2
int mid = l+r+1>>1;
if(check()){
	l=mid;
}else r=mid-1;
```

模板1用于当mid满足check条件目标不可能等于mid的情况，模板2适用于mid满足check条件时目标可能等于mid的情况

在此题中，由于需要精确找到目标，我们可以直接在循环中判断target == mid的情况直接返回。



关于while(l<r) 还是 while(l<=r)：

后者在l==r时还会执行一次，跳出后l>r，而前者在相等时直接跳出，跳出后l==r，需要在循环外部得出结果。



### Lc34 在排序数组中查找元素的第一个和最后一个位置

二分问题。与Lc33相似，需要找出目标的范围，使得目标在某种情况下一定在该范围内，不在某种情况下一定不在该范围内。

此题中，如果有数组[0,1,2,2,3,3,4]，我们要找2的第一个位置，当mid小于2时，x一定不在mid的左边，而当mid大于等于2时，x一定在mid右边或等于mid。

所以有

~~~
int mid = l+r>>1;
if(mid<target) l=mid+1;
else r=mid;
~~~

而找最后一个2的位置时，当mid大于2时，x一定不在mid的右边，且当mid小于等于2时，x一定在mid左边或等于mid；

所以有

~~~
int mid = l+r+1>1;
if(mid>target) r=mid-1;
else l=mid;
~~~



### Lc38 外观数组

遍历统计即可



### Lc39  组合总和

给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。



组合问题，第一时间想到回溯剪枝。

关于剪枝条件：

排序好后，如果target-num[i]<0，后续的循环也一定小于0，因为后续的num[i]更大，所以可以直接结束本次循环。



关键问题还是去重：

在无重复数组中，还是会出现重复元组的问题，是因为每次dfs都是遍历全部的元素，所以会出现访问已经访问过的元素的情况。

实际上当一个元素被访问完后，到下一个元素的dfs中再去访问这个元素，这个组合是已经被探查过的，不应该再次被访问。

所以可以设置一个循环起始点，当新的dfs开启时，只能从当前访问的元素开始，新的dfs也可以访问当前用到的元素，即允许多次重复使用一个元素，但不能再去访问历史的元素。



### Lc40 组合总和2

与Lc39不同的是，数组会有重复元素，去重的难度增加了。而且不能重复使用同一数字。

处理方式还是与Lc39类似，但由于不能重复使用同一数字，所以循环起始点不能从当前访问的元素开始了。

由于数组会有重复元素，需要加入新的去重条件。

去重的原理其实跟lc39的循环起始点类似。两个相同的元素，第一个元素遍历完成后，所有与第一个元素有关的方案都被试过了，第二个元素与第一个元素相同，产生的方案也是相同的，所以就没必要再遍历一次，直接跳过即可。

所以有：

~~~
if(i>begin&&nums[i]==nums[i-1]) continue;
~~~



### Lc43 字符串相乘

思路是模拟竖式乘法。

~~~
            123
            456
            ----
            6 12 18
         5 10 15
      4 10 12
  =
~~~

从后往前计算出乘积，计算出进位加到前一位。

两数相乘的最大位数是m+n。

计算出的结果前面可能存在多个0，需要去除。



### Lc45 跳跃游戏2*

贪心算法。

在i位置时，能跳到nums[i]+i，则看看从i到nums[i]+i中间有没有可以跳到更远的方法，即next+nums[next]更大，如果有就跳到新的位置。做一次这种选择就跳一步，最终跳到末尾。



### Lc46 全排列

无重复数据。

回溯剪枝即可，剪枝条件是当前搜索中已经用到的数据不能再访问



### Lc47 全排列2

在Lc46的基础上，增加了重复元素，所以对去重有了更高的要求。

关于两种去重方式：

思路1：存在两个相同的元素，以第一个元素开始的排列都遍历过之后，以第二个元素开始的排列与第一个元素完全相同，所以无需重复。

~~~
// 当第一个元素遍历完成后，会将第一个元素的访问标记恢复零
if (i > 0 && nums[i - 1] == nums[i] && flags[i - 1] == 0) continue;
~~~

思路2：存在两个相同元素，以第一个元素开始的排列启动搜索后，如果遇到第二个元素，就跳过，等到后面以第二个元素开始的排列搜索时，遇到第一个元素再加入。本质上是选定了一种顺序，就是两个元素都有的结果中，只计算以第二个元素开头的那个结果。

~~~
// 当遍历第一个元素时，遇到第二个元素跳过，反过来则不会跳过
if (i > 0 && nums[i - 1] == nums[i] && flags[i - 1] == 1) continue;
~~~



### Lc48 旋转图像

旋转矩阵90度等于上下翻转后转置

旋转180度等于上下翻转后左右翻转

旋转270度等于转置后上下翻转



### Lc49 字母异位词分组

异位词就是相同字符组成的不同词，如eat和ate。由于要分组，需要确定不同此词的相同点才可找出分组逻辑。由于异位词的字符和字符个数是相同的，排序之后的字符串也就相同了。分组可以使用hashmap很方便地分。

使用hashmap的getOrDefault方法可以快速判断是否存在并在不存在时获取一个list。



### Lc50 Power

即x^n，在实现中要想节省时间，需要减少计算量，计算次数的减少依赖于计算结果的复用。x\*x..x与 先计算x\*x=A,再用A\*A\*...A 计算结果，两者的计算次数是不一样的。

思路举例：把x^n划分成多个x的平方相乘。如把2^6变成2\*2 \* 2\*2 \* 2\*2 =4\*4\*4=4^3，这样相当于复用了2\*2的计算结果。4^3又可以变成4*4 *4 = 4^2\*4=16\*4 ;

实现的思路：

关键在于n的划分。6可以划分成3个2，即复用2*2的结果，使结果变成4^3，而3又可以划分成1个2和1个1，即使结果变成4^2 \* 4。所以流程是把n/2和余数n%2分别取出来，看看能分成多少个x的平方，再用平方的结果去计算pow(x\*x,n/2)。

负数与溢出的问题。该逻辑只能处理正数n，如果n为负数，需要变成1/(x^-n)，但n是int类型，负数范围比正数大，直接转正数会溢出，要用n=-1*(long)n



### Lc53 最大子序和

找到整数数组中有最大子序和的连续子数组，返回最大子序和。

一般找这种子数组、子串最值的问题都可以想想动态规划。思考能否使用动态规划的关键是，能否复用前面的结果。

本题中，定义以i为结尾的最大子序和f[i]，和以i-1为结尾的最大子序和f[i-1]，如果f[i-1]大于0，则f[i]可以加上f[i-1]，让自己变得更大。如果f[i-1]小于0，则没有必要加了。



问题是，以i结尾的子串这个定义是如何想出来的，思考这个问题对后续相似的情况会有所帮助。

这种定义是对下标i定义的延申，即想明白i是什么，就知道f[i]定义是什么。在本题中，连续子数组是我们所求最值属性的主体，这个主体的属性除了数值和以外，还有长度和首尾下标。通常不会以长度作为i的定义，因为长度很难遍历，而i是需要用作遍历的，以长度定义i通常会出现在不确定起始遍历位置的场景中。所以本题中i就作为首或者尾的下标，一般都会用尾下标作为定义，因为这样可以限制当前遍历的数据范围。

可以写出状态转移方程：if(f[i-1]>0) f[i]=f[i-1]+nums[i]  else f[i]=nums[i];



### Lc54 螺旋矩阵

顺时针输出矩阵元素

![螺旋矩阵](https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg)

思路上并不是非常复杂，但实现上需要一些帮助减少特殊边界条件的设计。

由于遍历时上下左右的范围是在变小的，如果能记录上下左右的范围，遍历一个边界就更新一下边界值，就可以在for循环中放心地移动指针。

比如遍历了1->2->3，就把上边界+1，等下次遍历上边界时，就可以从第二行开始遍历。



这种边界逐渐变化的问题，应该在某些条件完成后立刻调整边界，如果等下一次使用到这个边界时再去计算边界值就会比较复杂，甚至会因为条件变化计算不出来。



### Lc55 跳跃游戏

判断能否跳到最后一个。

思路与跳跃游戏2一致，选择能跳得最远的下一步，直到跳出循环，如果还没到达末尾就无法到达。

关键在如何选择下一步。从i能跳到i+nums[i]，如果在i和nums[i]+i之间，还有其他点可以跳得更远，就选择这个更远的点。这样能选择出从i开始跳得最远的方法。





### Lc56 合并区间

合并目标区间数组中重合的区间。

```
[[1,4],[4,5]]=> [1,5]
```

首先为了合并方便，有序是必须的，需要按照区间左边界排序。然后从头开始遍历，如果遇到一个区间的右边界比后面多个区间的左边界大或者相等，就可以合并这些区间，取其中最大的右边界。

这个逻辑中，因为是向后查询可合并的区间，如果最后一个区间不可合并，将不会被遍历到，需要在外部特殊考虑。

关于List<int[]> 转 int\[\]\[\]:

~~~
res.toArray(new int[0][]);
~~~





### Lc57 插入区间

在多个无重叠区间内插入一个新的区间，使得新生成的区间互不干扰

插入一个区间要知道插入区间的左边界和右边界分别落在区间数组的哪些位置，即确定新区间影响的范围。

这样可以把原区间分为三段，第一段是新区间不影响的范围，第二段是新区间影响的范围，第三段也是不影响的范围。

第一段只要保证新区间的左边界比他们右边界还大即可。

找完第一段后面就是第二段的起始，问题是找到结束位置，当新区间的右边界小于等于某个区间的左边界时，说明新区间不会影响这个区间了，前面的就是受影响的位置。

第三段就是剩下的。

在第二段中，由于都是受新区间影响的，都会连成一片，所以只要用里面最大的右边界和最小的左边界生成区间就行。



### Lc59 螺旋矩阵2

给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 

相当于螺旋矩阵1的反过程。同样的需要不断更改各个边界来减少边界值问题。



### Lc61 旋转链表

给你一个链表的头节点 head，旋转链表，将链表每个节点向右移动 k 个位置。

快慢指针法，快指针从head开始先走k步，再慢指针启动与快指针一同移动，直到快指针到达末尾，此时慢指针应该指向倒数第k+1个（因为是从head开始的，起始就是1），正好慢指针后面的节点数是k，也就是我们要移动的节点数，从慢指针位置操作后续链表移动到head前面即可。



### Lc71 简化路径

给你一个字符串 path ，表示指向某一文件或目录的 Unix 风格 绝对路径。"."表示自身，“..”表示父节点，”...“表示文件名，”//" = “/"。最后一个目录名（如果存在）不能 以 '/' 结尾。

在条件中发现有..表示父节点的情况，相当于要把之前存的结果删除，这是一个栈的操作，但输出又需要先进先出，所以可以用双端队列来实现。

首先可以用split把path分割成字符串，这样通过比对字符串就可以判断当前遇到的是什么情况，而不需要通过char来匹配。

如果遇到..就将双端队列的最后一个结果删除，对应双端队列的pollLast，如果遇到.和//都跳过，其他则offer，插入队列尾部

在输出时，用poll操作从队首开始输出。



### Lc73 矩阵置零

把矩阵中存在0的行和列全部置0，要求空间复杂度O(1)

在矩阵置零的过程中会遇到的问题是，当前访问的0是转变之后的还是转变之前的，比如上层的某次转换把当前行的某个值变成0了，当遍历到这个值是，如何判断它原本是不是0。

这个问题采用标记法是可以解决的，如果给每个元素都标记是否被转变过，空间复杂度是O(m*n)，不符合要求。

可以简化为给每一行和每一列标记，因为只要一行里有一个是0，整行都会被置零，所以只要标记这行里存不存在0就行。这样的空间复杂度是O(m+n)，不符合要求。

行和列的标记可以放在第一行和第一列，而不需要开辟额外的空间。产生的问题是第一行和第一列的数据被覆盖了，这两行是否有0不知道，需要预先用两个标记来记录。

第一行是否有0可以用第一列的第一个值来判断，所以并不需要对第一行做标记，只需要一个列标记即可。

在置零时需要注意不能把第一行和第一列覆盖掉，可以采用倒着遍历的方式



### Lc74 搜索二维矩阵

矩阵的特点

- 每行中的整数从左到右按升序排列。
- 每行的第一个整数大于前一行的最后一个整数。

![搜索二维矩阵](https://assets.leetcode.com/uploads/2020/10/05/mat.jpg)

可以先在第一列二分查找，找到目标可能在的行，再到行上二分查找目标值。

两次二分查找的目的不太一样，第一次是找小于等于目标的最大值，第二次是找目标值



### Lc75 颜色分类

荷兰国旗问题，将三种颜色按顺序排列在一起。

相当于给由0,1,2三种数字组成的乱序数组排序。

由于数字是固定的三种，完全可以统计每种颜色的数量，然后按顺序生成即可。但这样需要遍历两边，复杂度会差一点，要在一次遍历过程中就实现分类和排序，可以联想生活中排不同颜色棋子的场景。

![](img/leetcode/75/原始顺序.png)

要把黄棋移动到右边，只要从前往后找到一个黄棋的时候跟最后一个交换，于是得到：

![](img/leetcode/75/顺序2.png)

然后再找到一个黄棋与倒数第三个交换：

![](img/leetcode/75/顺序3.png)

观察得到，在找到黄棋时，要交换的位置是右边黄棋影响范围的左边界前一个位置。

同理，如果要把蓝棋移动到左边，只需要在找到蓝棋时跟左边蓝棋影响范围的右边界的后一个位置交换即可。

### Lc111 二叉树的最小深度

中序遍历找到叶子节点。左右两支返回的高度如果有一方是0，说明有一支为null，需要往另一支继续探索。如果两方都不为0，取较小的一方即可。