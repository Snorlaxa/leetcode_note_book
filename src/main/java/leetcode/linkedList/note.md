# 总结

## AddTwoNUmber

### 关于不同长度链表的遍历

不同长度链表的同步遍历可能出现的最大问题是：一个链表终结后，另一个链表的剩余部分如何优雅地处理。如果启动新的while循环来处理剩余链表会导致代码结构复杂，并且要考虑剩余部分的长度为0等特殊情况。

解决方法是一个链表终结后仍然保持当前循环，只是终结链表不再向后遍历，其值被赋予无效值（比如0），这样就能在一个循环中处理两个不同长度的链表。

### 关于遍历循环的跳出条件

> 用p!=null还是p.next!=null ?

+ p!=null 的适用场景

跳出时p会等于遍历到链表最后节点的next，while循环处理了所有节点的数据

+ p.next!=null 的适用场景

跳出时p会等于链表的最后一个节点，while循环处理了最后一个节点之前的全部数据，最后一个节点会保留

### 关于链表循环的起始，如何做到不需要处理起始的特殊情况

构造有头链表，head.next指向链表头，然后遍历指针p指向head。

这样在循环的时候就可以维持p.next的统一操作，如果p指向链表头（即head.next），会出现第一个节点需要特殊处理的情况。

有头链表遍历:
>
> //无需考虑第一个节点的情况
>
> ListNode p = new ListNode();
>
> p.next = l1;
>
> while(p.next!=null){}


无头链表遍历：
> //考虑第一个节点为null
>
> if(p!=null){
>
>   // 处理第一个节点
>
>   process(p);
>
>   // 处理后续节点
>
>   while(p.next!=null){}
>
> }
两者相差很大