# Leetcode 题解思路总结

### Lc11 盛最多水的容器

![盛水最多的容器](https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg)

典型的双指针法题目。

盛水的多少取决于两块板的高度和中间的距离，这种取决于多个因素取最值的问题，可以采用先固定一个因素，逐步缩减其他因素的思想。

如此题中先确定两块板的距离，首先采用最远距离的两块板，计算出盛水容量，然后变动某一块板的高度观察是否能取得更多的盛水量。高度取决于短的一块板，所以移动短的一块板。如果移动一步并没有使容量增大，则继续移动短的一块。直到找到更大的。

在此步骤中，由于要移动左右两块板，双指针法显然是最合适的。



### Lc15 三数之和

判断是否有三个数和等于目标数。



与Lc11的思路一样，三个加数相当于三个变量，我们需要固定其中一个，变动剩余两个来寻找最合适的结果。这种剩余两个变量的情况一般都采用双指针。在指针移动时必须能够确定移动后的结果比当前结果更靠近目标还是更远离目标，在这里乱序的数组并不能保证，所以需要先排序。



具体的实现思路是：排序后，先固定一个数A，在后续的数据中用双指针法寻找两个数，使得两数相加等于target-A；

由于原始数据是可能有重复值的，又不允许重复三元组，所以去重是关键点。

去重一般会想到HashMap，但最好是能在逻辑中去除相同的结果，这样会省去很多查询结束后的处理过程。

在本题的查询过程中，重复结果都是由重复数据引起的，所以在双指针遍历过程中，左右指针都不访问相同的元素就可以做到去重。因为先进行了排序，重复的数据都排在一起，所以实现还是比较方便的。



### Lc16 最接近的三数之和

找出与目标值最接近的三个数之和

跟Lc15的题目很像，思路也是类似，仍然是固定一个数，双指针查找另外两个数，这里是找最接近的和，所以要在遍历过程中加入查找max的逻辑。因为只要返回和，就不需要去重操作了。



### Lc19 删除链表的倒数第 N 个结点

快慢指针法。让一个指针先走N步，当快指针到达末尾时，慢指针正好指向倒数第n+1个节点，即可删除。

注意特殊情况，如只有一个节点、删除头节点等



### Lc22 括号生成

生成n对括号，输出所有可能的组合。

这种全排列问题通过回溯剪枝法都可以解决。

回溯法最好是用递归去写，简洁方便，迭代比较复杂。

剪枝的条件比较明显，当结果中右括号的数量比左括号还多时，说明当前的结果中出现了没有对应左括号的右括号，就可以不用往下找了。

递归的终止条件是左右括号数量都用完了。



### Lc22 两两交换链表中的节点

观察交换两个节点的过程会发现，交换过程中会影响三个节点，这两个节点和前一个节点，而链表的第一个节点没有前节点，可以加入一个pre节点指向head。

这样在交换过程中形式统一。

可以采用迭代或者递归的形式，每次交换完成后，pre指针向后移动两次，正好指向后面要交换的两个节点的前一节点。



### Lc29 两数相除

模拟整数除法，数据范围[-2^31,2^31-1]，如果结果溢出返回2^31-1。不能使用乘法。

因为无法使用乘法，想快速累积被除数的倍数只能通过左移<<，相当于乘以2^n。

举例：

25除以4:

25=16+8+1=4\*4+4\*2+1=4<<2 + 4<<1 + 1

即25/4的结果等于2^2+2^1=4+2=6



在实现的过程中，该流程表现为25-4<<i++; 其中i从0开始不断增加，

关于溢出的处理：

+ 在计算之前要对-1，1，0等做特殊处理
+ 由于负数的范围是[-2^31,0]比正数要大，所以可以全部转换成负数来算，等计算出结果再计算正负。
+ 在计算过程中，由于存在对除数的左移，是有可能存在溢出情况的，需要判断左移是否会溢出。判断的方法是，把Integer.MIN_VALUE>>i右移相同位数，看看当前值是不是比这个值还小，如果更小再左移就会溢出了。
+ 当左移后的数据比当前结果还要大时（全换成负数时是更小），说明已经除完了。此时如果左移的结果溢出，应该用Integer.MIN_VAULE来替换。



### Lc33 搜索旋转排序数组

旋转数组是把有序数组的头部一段数组移动拼接到尾部。要求O(logn)

从时间复杂度看很明显要用二分。

有序并不是二分的必要条件，二分的本质是找到目标的确切范围，如果能够确定在某种情况下目标一定在某一个范围内，且不在这种情况下目标一定不在该范围内，就可以用这个逻辑作为二分的条件。二分的关键就是找到这种条件。

比如在此题中，可以通过mid与数组首个数字的对比判断mid落在前半部分还是后半部分。缩小一次范围的情况下，如果mid落在前半部分，如果x也落在前半部分而且比mid要小，说明x一定在start和mid中间，这样就形成了一个二分条件。同理如果mid落在后半部分，x也落在后半部分且比mid要大，x一定在mid和end中间，也形成了一个二分条件。



关于模板：

```
// 模板1
int mid = l+r>>1;
if(check()){
	l=mid+1;
}else r=mid;

// 模板2
int mid = l+r+1>>1;
if(check()){
	l=mid;
}else r=mid-1;
```

模板1用于当mid满足check条件目标不可能等于mid的情况，模板2适用于mid满足check条件时目标可能等于mid的情况

在此题中，由于需要精确找到目标，我们可以直接在循环中判断target == mid的情况直接返回。



关于while(l<r) 还是 while(l<=r)：

后者在l==r时还会执行一次，跳出后l>r，而前者在相等时直接跳出，跳出后l==r，需要在循环外部得出结果。



### Lc34 在排序数组中查找元素的第一个和最后一个位置

二分问题。与Lc33相似，需要找出目标的范围，使得目标在某种情况下一定在该范围内，不在某种情况下一定不在该范围内。

此题中，如果有数组[0,1,2,2,3,3,4]，我们要找2的第一个位置，当mid小于2时，x一定不在mid的左边，而当mid大于等于2时，x一定在mid右边或等于mid。

所以有

~~~
int mid = l+r>>1;
if(mid<target) l=mid+1;
else r=mid;
~~~

而找最后一个2的位置时，当mid大于2时，x一定不在mid的右边，且当mid小于等于2时，x一定在mid左边或等于mid；

所以有

~~~
int mid = l+r+1>1;
if(mid>target) r=mid-1;
else l=mid;
~~~



### Lc38 外观数组

遍历统计即可



### Lc39  组合总和

给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。



组合问题，第一时间想到回溯剪枝。

关于剪枝条件：

排序好后，如果target-num[i]<0，后续的循环也一定小于0，因为后续的num[i]更大，所以可以直接结束本次循环。



关键问题还是去重：

在无重复数组中，还是会出现重复元组的问题，是因为每次dfs都是遍历全部的元素，所以会出现访问已经访问过的元素的情况。

实际上当一个元素被访问完后，到下一个元素的dfs中再去访问这个元素，这个组合是已经被探查过的，不应该再次被访问。

所以可以设置一个循环起始点，当新的dfs开启时，只能从当前访问的元素开始，新的dfs也可以访问当前用到的元素，即允许多次重复使用一个元素，但不能再去访问历史的元素。



### Lc40 组合总和2

与Lc39不同的是，数组会有重复元素，去重的难度增加了。而且不能重复使用同一数字。

处理方式还是与Lc39类似，但由于不能重复使用同一数字，所以循环起始点不能从当前访问的元素开始了。

由于数组会有重复元素，需要加入新的去重条件。

去重的原理其实跟lc39的循环起始点类似。两个相同的元素，第一个元素遍历完成后，所有与第一个元素有关的方案都被试过了，第二个元素与第一个元素相同，产生的方案也是相同的，所以就没必要再遍历一次，直接跳过即可。

所以有：

~~~
if(i>begin&&nums[i]==nums[i-1]) continue;
~~~



### Lc43 字符串相乘

思路是模拟竖式乘法。

~~~
            123
            456
            ----
            6 12 18
         5 10 15
      4 10 12
  =
~~~

从后往前计算出乘积，计算出进位加到前一位。

两数相乘的最大位数是m+n。

计算出的结果前面可能存在多个0，需要去除。



### Lc45 跳跃游戏2*

贪心算法。

在i位置时，能跳到nums[i]+i，则看看从i到nums[i]+i中间有没有可以跳到更远的方法，即next+nums[next]更大，如果有就跳到新的位置。做一次这种选择就跳一步，最终跳到末尾。



### Lc46 全排列

无重复数据。

回溯剪枝即可，剪枝条件是当前搜索中已经用到的数据不能再访问



### Lc47 全排列2

在Lc46的基础上，增加了重复元素，所以对去重有了更高的要求。

关于两种去重方式：

思路1：存在两个相同的元素，以第一个元素开始的排列都遍历过之后，以第二个元素开始的排列与第一个元素完全相同，所以无需重复。

~~~
// 当第一个元素遍历完成后，会将第一个元素的访问标记恢复零
if (i > 0 && nums[i - 1] == nums[i] && flags[i - 1] == 0) continue;
~~~

思路2：存在两个相同元素，以第一个元素开始的排列启动搜索后，如果遇到第二个元素，就跳过，等到后面以第二个元素开始的排列搜索时，遇到第一个元素再加入。本质上是选定了一种顺序，就是两个元素都有的结果中，只计算以第二个元素开头的那个结果。

~~~
// 当遍历第一个元素时，遇到第二个元素跳过，反过来则不会跳过
if (i > 0 && nums[i - 1] == nums[i] && flags[i - 1] == 1) continue;
~~~



### Lc48 旋转图像

旋转矩阵90度等于上下翻转后转置

旋转180度等于上下翻转后左右翻转

旋转270度等于转置后上下翻转

